package net.corda.did.api

import com.natpryce.onFailure
import net.corda.core.messaging.startFlow
import net.corda.core.node.services.vault.builder
import net.corda.core.utilities.getOrThrow
import net.corda.core.utilities.loggerFor
import net.corda.did.api.MainController.Companion.logger
import net.corda.did.flows.CreateDidFlow
import net.corda.did.flows.DeleteDidFlow
import net.corda.did.flows.UpdateDidFlow
import net.corda.did.utils.DIDAlreadyExistException
import net.corda.did.utils.DIDNotFoundException
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.MediaType.APPLICATION_JSON_VALUE
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RequestPart
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.context.request.async.DeferredResult
import java.util.concurrent.Executors

/**
 *  A Spring Boot Server API controller for interacting with the node via RPC.
 *
 */

@RestController
@RequestMapping("/")
// ??? moritzplatt 2019-06-20 -- consider passing connection parameters instead so the controller can manage the connection
// itself. i.e. re-establishing connection in case it fails or adding functionality to re-establish a connection in case of errors

// pranav 2019-06-25 added RPC reconnection library to reconnect if node connection is lost,docs@ https://docs.corda.net/clientrpc.html#reconnecting-rpc-clients
/**
 * @property proxy The node RPC connection object instance
 * @property queryUtils Helper function used to query the ledger.
 * @property apiUtils Helper functions used to form API responses.
 * @property executorService Is used for creating new threads for tasks that are blocking.
 * @property logger Is used for logging
 * */
class MainController(rpc: NodeRPCConnection) {

	companion object {
		val logger = loggerFor<MainController>()

	}

	private val proxy = rpc.proxy
	private val queryUtils = QueryUtil(proxy)
	private val apiUtils = APIUtils()

	private val executorService = Executors.newSingleThreadExecutor()

	/**
	 * Method to create a DID in the Corda ledger via REST
	 *
	 * @param[did] This is the unique decentralized identifier generated by the client application.
	 * @param[document] The raw DID document that contains the encoded public keys and their information.
	 * @param[instruction] Contains the encoded signature on the document as well as the action to be performed by the backend create,update,delete etc.
	 * @return A json response with a status code of 200 if create operation was a success,409 if conflict, 400 due to any other error in the sent parameters.
	 * */
	@PutMapping(value = "{did}",
			produces = arrayOf(MediaType.APPLICATION_JSON_VALUE), consumes = arrayOf(MediaType.MULTIPART_FORM_DATA_VALUE))
	fun createDID(@PathVariable(value = "did") did: String, @RequestPart("instruction") instruction: String, @RequestPart("document") document: String): DeferredResult<ResponseEntity<Any?>> {
		/**
		 * Creates an instance of Deferred Result, this will be used to send responses from tasks running in separate threads
		 *
		 * */
		val apiResult = DeferredResult<ResponseEntity<Any?>>()
		try {
			/**
			 * Takes instruction,document and did as input, validates them and returns an envelope Object.
			 *
			 * */
			val envelope = apiUtils.generateEnvelope(instruction, document, did)
			/**
			 *  Checks if the provided 'did' is in the correct format.
			 *
			 * */
			net.corda.did.CordaDid.parseExternalForm(did).onFailure { apiResult.setErrorResult(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse(APIMessage.INCORRECT_FORMAT).toResponseObj()));return apiResult }

			// ??? moritzplatt 2019-06-20 -- suggestion here would be to remove this block and instead of querying, rely on the output of the startFlowDynamic call only
			// the current implementation introduces a race condition between the `getDIDDocumentByLinearId` call and the
			// consumption of the `returnValue`
			//pranav 2019-06-27-- removed as per review comment

			/**
			 * Checks to see if the generated envelope is correct for the creation use case, otherwise returns the appropriate error.
			 *
			 * */
			val envelopeVerified = envelope.validateCreation()
			envelopeVerified.onFailure { apiResult.setErrorResult(apiUtils.sendErrorResponse(it.reason));return apiResult }

			// ??? moritzplatt 2019-06-20 -- as described in comments on the flow logic, this should not be passed from the API

			/* WIP :Need clarification from Moritz on how the witnesses can be fetched*/

			// ??? moritzplatt 2019-06-20 -- the API should not be aware of the witnesses. The CorDapp should be aware
			// of the set of witnesses by configuration. Considering all network members witnesses is incorrect.

			// ??? moritzplatt 2019-06-20 -- consider comments on the flow constructor
			//pranav: 2019-06-27 As per Moritz comments we are now just passing envelope to flow
			/**
			 * Passing the generated envelope as a parameter to the CreateDidFlow.
			 *
			 * Returns a flow handler
			 * */
			val flowHandler = proxy.startFlowDynamic(CreateDidFlow::class.java, envelope)

			// ??? moritzplatt 2019-06-20 -- not familiar with Spring but `getOrThrow` is blocking.
			// Maybe there is a pattern around futures (i.e. https://www.baeldung.com/spring-async)?
			// Just a thought though
			// pranav: 2019-06-27 added logic to for asynchronous execution of blocking code
			/**
			 * Executes the flow in a separate thread and returns result.
			 *
			 * Throws exception if flow invocation fails
			 * */
			executorService.submit {
				try {

					val result = flowHandler.use { it.returnValue.getOrThrow() }
					apiResult.setResult(ResponseEntity.ok().body(ApiResponse(result.toString()).toResponseObj()))
				} catch (e: IllegalArgumentException) {
					apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))

				} catch (e: DIDDeletedException) {
					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.DID_DELETED).toResponseObj(), HttpStatus.CONFLICT))
				} catch (e: DIDAlreadyExistException) {
					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.CONFLICT).toResponseObj(), HttpStatus.CONFLICT))

				}

			}

			return apiResult

		} catch (e: Exception) {
			logger.error(e.message)
			apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))
			return apiResult
		}

	}
/*
* Fetch DID document
* */
	/**
	 * Method to fetch a DID from the Corda ledger via REST
	 *
	 * @param[did] This is the unique decentralized identifier generated by the client application.
	 * @return The raw DID document if found ,returns 404 if not found ,returns 400 error if incorrect format is passed.
	 * */
	@GetMapping("{did}", produces = [APPLICATION_JSON_VALUE])
	fun fetchDIDDocument(@PathVariable(value = "did") did: String): ResponseEntity<Any?> {

		try {
			/**
			 * Converts the "did" from external form to uuid form else returns an error
			 *
			 * */
			val uuid = net.corda.did.CordaDid.parseExternalForm(did).onFailure { return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse(APIMessage.INCORRECT_FORMAT).toResponseObj()) }

			builder {
				/**
				 * Query the ledger using the uuid and return raw document else return an error.
				 *
				 * */
				val didJson = queryUtils.getDIDDocumentByLinearId(uuid.uuid.toString())
				if (didJson.isEmpty()) {
					val response = ApiResponse(APIMessage.NOT_FOUND)
					return ResponseEntity(response.toResponseObj(), HttpStatus.NOT_FOUND)

				}
				// ??? moritzplatt 2019-06-20 -- do not return the re-serialised version based on JsonObject. Signatures may not match
				// pranav 2019-06-25 updated code to return raw document as a string
				return ResponseEntity.ok().body(didJson)
			}
		} catch (e: IllegalArgumentException) {
			logger.error(e.toString())
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse(APIMessage.INCORRECT_FORMAT).toResponseObj())

		} catch (e: IllegalStateException) {
			logger.error(e.toString())
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse(APIMessage.INCORRECT_FORMAT).toResponseObj())

		} catch (e: DIDDeletedException) {
			return ResponseEntity(ApiResponse(APIMessage.DID_DELETED).toResponseObj(), HttpStatus.NOT_FOUND)

		} catch (e: Exception) {
			logger.error(e.toString())
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ApiResponse(e.message).toResponseObj())
		}
	}

	/**
	 * Method to update a DID in the Corda ledger via REST
	 *
	 * @param[did] This is the unique decentralized identifier generated by the client application.
	 * @param[document] The raw DID document that contains the encoded public keys and their information.
	 * @param[instruction] Contains the encoded signature on the document as well as the action to be performed by the backend create,update,delete etc.
	 * @return A json response with a status code of 200 if update operation was a success,404 if not found, 400 due to any other error in the sent parameters.
	 * */
	@PostMapping(value = "{did}",
			produces = arrayOf(MediaType.APPLICATION_JSON_VALUE), consumes = arrayOf(MediaType.MULTIPART_FORM_DATA_VALUE))
	fun updateDID(@PathVariable(value = "did") did: String, @RequestParam("instruction") instruction: String, @RequestParam("document") document: String): DeferredResult<ResponseEntity<Any?>> {
		/**
		 * Creates an instance of Deferred Result, this will be used to send responses from tasks running in separate threads
		 *
		 * */
		val apiResult = DeferredResult<ResponseEntity<Any?>>()
		try {
			/**
			 * Takes instruction,document and did as input, validates them and returns an envelope Object.
			 *
			 * */
			val envelope = apiUtils.generateEnvelope(instruction, document, did)
			/**
			 * Converts the "did" from external form to uuid form else returns an error
			 *
			 * */
			val uuid = net.corda.did.CordaDid.parseExternalForm(did).onFailure { apiResult.setErrorResult(ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse(APIMessage.INCORRECT_FORMAT).toResponseObj()));return apiResult }

			// ??? moritzplatt 2019-06-20 -- merge with assignment var didJson = try { ... }
			//pranav 2019-06-27 --changed as per review comment
			/**
			 * Perform a check at the API layer to make sure that the data provided meets the criteria for update,before passing it to the flow.
			 *
			 * */
			try {
				val didJson = queryUtils.getCompleteDIDDocumentByLinearId(uuid.uuid.toString())
				val envelopeVerified = envelope.validateModification(didJson)
				envelopeVerified.onFailure { apiResult.setErrorResult(apiUtils.sendErrorResponse(it.reason));return apiResult }
			} catch (e: NullPointerException) {

				apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.NOT_FOUND).toResponseObj(), HttpStatus.NOT_FOUND))
				return apiResult
			} catch (e: DIDDeletedException) {
				apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.DID_DELETED).toResponseObj(), HttpStatus.NOT_FOUND))
				return apiResult
			}

			/**
			 * Passing the generated envelope as a parameter to the UpdateDidFlow.
			 * Returns a flow handler
			 * */
			val flowHandler = proxy.startFlowDynamic(UpdateDidFlow::class.java, envelope)
			/**
			 * Executing the flow in a separate thread and return result.
			 * Throws exception if flow invocation fails
			 * */

			executorService.submit {
				try {
					val result = flowHandler.use { it.returnValue.getOrThrow() }
					apiResult.setResult(ResponseEntity.ok().body(ApiResponse(result.toString()).toResponseObj()))
				} catch (e: IllegalArgumentException) {

					apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))

				} catch (e: DIDNotFoundException) {

					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.NOT_FOUND).toResponseObj(), HttpStatus.NOT_FOUND))
				} catch (e: DIDDeletedException) {

					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.DID_DELETED).toResponseObj(), HttpStatus.NOT_FOUND))
				}

			}


			return apiResult

		} catch (e: Exception) {
			logger.error(e.message)
			apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))
			return apiResult
		}
	}

	// ??? moritzplatt 2019-06-20 -- does a `DELETE` require a document at all? it could be an instruction set only?
	//pranav 2019-06-27 - updated the code to accept only instruction
	/**
	 * Method to delete a DID in the Corda ledger via REST
	 *
	 * @param[did] This is the unique decentralized identifier generated by the client application.
	 * @param[instruction] Contains the encoded signature on the latest DID document as well as the action to be performed by the backend (delete).
	 * @return A json response with a status code of 200 if delete operation was a success,404 if not found , 400 due to any other error in the sent parameters.
	 * */
	@DeleteMapping(value = "{did}",
			produces = arrayOf(MediaType.APPLICATION_JSON_VALUE), consumes = arrayOf(MediaType.MULTIPART_FORM_DATA_VALUE))
	fun deleteDID(@PathVariable(value = "did") did: String, @RequestPart("instruction") instruction: String): DeferredResult<ResponseEntity<Any?>> {
		val apiResult = DeferredResult<ResponseEntity<Any?>>()
		try {
			/**
			 * Passing the instruction and did to the DeleteDidFlow
			 *
			 * */
			val flowHandler = proxy.startFlow(::DeleteDidFlow, instruction, did)
			/**
			 * Executing the flow in a separate thread and return result.
			 *
			 * Throws exception if flow invocation fails
			 * */
			executorService.submit {
				try {
					val result = flowHandler.use { it.returnValue.getOrThrow() }

					apiResult.setResult(ResponseEntity.ok().body(ApiResponse(result.toString()).toResponseObj()))
				} catch (e: IllegalArgumentException) {

					apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))

				} catch (e: DIDNotFoundException) {

					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.NOT_FOUND).toResponseObj(), HttpStatus.NOT_FOUND))
				} catch (e: DIDDeletedException) {

					apiResult.setErrorResult(ResponseEntity(ApiResponse(APIMessage.DID_DELETED).toResponseObj(), HttpStatus.NOT_FOUND))
				}

			}

			return apiResult

		} catch (e: Exception) {
			logger.error(e.message)
			apiResult.setErrorResult(ResponseEntity.badRequest().body(ApiResponse(e.message).toResponseObj()))
			return apiResult
		}
	}
}
